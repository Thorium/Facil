// Edit or remove this or the below line to regenerate on next build
// Hash: ec4196fdeca504a95b940d172d4e2e6aa63ae84bd667a47bef8cdaf642f28bf4

//////////////////////////////////////////
//
// THIS FILE IS AUTOMATICALLY GENERATED
//
// Facil 0.1.5
//
//////////////////////////////////////////

module DbGen

#nowarn "49"

open System
open System.ComponentModel
open System.Data
open System.Threading
open Microsoft.Data.SqlClient
open Microsoft.Data.SqlClient.Server
open Facil.Runtime.CSharp
open Facil.Runtime.GeneratedCodeUtils


module MyPreludeModule =
  let x = 2



[<EditorBrowsable(EditorBrowsableState.Never)>]
type InternalUseOnly = private | InternalUseOnly
[<EditorBrowsable(EditorBrowsableState.Never)>]
let internalUseOnlyValue = InternalUseOnly


module TableDtos =


  module ``dbo`` =


    type ``OptionTableWithDto`` =
      {
        Col1: string option
        Col2: int option
      }


    type ``VoptionTableWithDto`` =
      {
        Col1: string voption
        Col2: int voption
      }


    type ``Table1`` =
      {
        TableCol1: string
        TableCol2: int option
      }


    type ``TableWithSkippedUnsupportedColumn`` =
      {
        SupportedCol1: string
        SupportedCol2: int
      }


module TableTypes =


  module ``dbo`` =


    let private ``MultiColNullVoption_meta`` = 
      [|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |]


    type ``MultiColNullVoption`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MultiColNullVoption_meta``)

      static member create
        (
          ``Foo``: int voption,
          ``Bar``: string voption
        ) =
        let x = ``MultiColNullVoption``(internalUseOnlyValue)
        x.SetValues(
          ValueOption.toDbNull ``Foo``,
          ValueOption.toDbNull ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNullVoption``(internalUseOnlyValue)
        x.SetValues(
          ValueOption.toDbNull (^a: (member ``Foo``: int voption) dto),
          ValueOption.toDbNull (^a: (member ``Bar``: string voption) dto)
        )
        |> ignore
        x


    let private ``MultiColNonNull_meta`` = 
      [|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |]


    type ``MultiColNonNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MultiColNonNull_meta``)

      static member create
        (
          ``Foo``: int,
          ``Bar``: string
        ) =
        let x = ``MultiColNonNull``(internalUseOnlyValue)
        x.SetValues(
          ``Foo``,
          ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNonNull``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``Foo``: int) dto),
          (^a: (member ``Bar``: string) dto)
        )
        |> ignore
        x


    let private ``MultiColNull_meta`` = 
      [|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |]


    type ``MultiColNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``MultiColNull_meta``)

      static member create
        (
          ``Foo``: int option,
          ``Bar``: string option
        ) =
        let x = ``MultiColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull ``Foo``,
          Option.toDbNull ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``Foo``: int option) dto),
          Option.toDbNull (^a: (member ``Bar``: string option) dto)
        )
        |> ignore
        x


    let private ``SingleColNonNull_meta`` = 
      [|
        SqlMetaData("Foo", SqlDbType.Int)
      |]


    type ``SingleColNonNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``SingleColNonNull_meta``)

      static member create
        (
          ``Foo``: int
        ) =
        let x = ``SingleColNonNull``(internalUseOnlyValue)
        x.SetValues(
          ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``SingleColNonNull``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``Foo``: int) dto)
        )
        |> ignore
        x


    let private ``SingleColNull_meta`` = 
      [|
        SqlMetaData("Foo", SqlDbType.Int)
      |]


    type ``SingleColNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``SingleColNull_meta``)

      static member create
        (
          ``Foo``: int option
        ) =
        let x = ``SingleColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``SingleColNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``Foo``: int option) dto)
        )
        |> ignore
        x


    let private ``LengthTypes_meta`` = 
      [|
        SqlMetaData("binary", SqlDbType.Binary, 3L)
        SqlMetaData("char", SqlDbType.Char, 3L)
        SqlMetaData("nchar", SqlDbType.NChar, 3L)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 3L)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 3L)
        SqlMetaData("varchar", SqlDbType.VarChar, 3L)
      |]


    type ``LengthTypes`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``LengthTypes_meta``)

      static member create
        (
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) =
        let x = ``LengthTypes``(internalUseOnlyValue)
        x.SetValues(
          ``binary``,
          ``char``,
          ``nchar``,
          ``nvarchar``,
          ``varbinary``,
          ``varchar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``LengthTypes``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``binary``: byte []) dto),
          (^a: (member ``char``: string) dto),
          (^a: (member ``nchar``: string) dto),
          (^a: (member ``nvarchar``: string) dto),
          (^a: (member ``varbinary``: byte []) dto),
          (^a: (member ``varchar``: string) dto)
        )
        |> ignore
        x


    let private ``AllTypesNonNull_meta`` = 
      [|
        SqlMetaData("bigint", SqlDbType.BigInt)
        SqlMetaData("binary", SqlDbType.Binary, 42L)
        SqlMetaData("bit", SqlDbType.Bit)
        SqlMetaData("char", SqlDbType.Char, 42L)
        SqlMetaData("date", SqlDbType.Date)
        SqlMetaData("datetime", SqlDbType.DateTime)
        SqlMetaData("datetime2", SqlDbType.DateTime2, 0uy, 3uy)
        SqlMetaData("datetimeoffset", SqlDbType.DateTimeOffset, 0uy, 1uy)
        SqlMetaData("decimal", SqlDbType.Decimal, 10uy, 5uy)
        SqlMetaData("float", SqlDbType.Float)
        SqlMetaData("image", SqlDbType.Image)
        SqlMetaData("int", SqlDbType.Int)
        SqlMetaData("money", SqlDbType.Money)
        SqlMetaData("nchar", SqlDbType.NChar, 42L)
        SqlMetaData("ntext", SqlDbType.NText)
        SqlMetaData("numeric", SqlDbType.Decimal, 8uy, 3uy)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 42L)
        SqlMetaData("real", SqlDbType.Real)
        SqlMetaData("smalldatetime", SqlDbType.SmallDateTime)
        SqlMetaData("smallint", SqlDbType.SmallInt)
        SqlMetaData("smallmoney", SqlDbType.SmallMoney)
        SqlMetaData("text", SqlDbType.Text)
        SqlMetaData("time", SqlDbType.Time, 0uy, 1uy)
        SqlMetaData("tinyint", SqlDbType.TinyInt)
        SqlMetaData("uniqueidentifier", SqlDbType.UniqueIdentifier)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 42L)
        SqlMetaData("varchar", SqlDbType.VarChar, 42L)
        SqlMetaData("xml", SqlDbType.Xml)
      |]


    type ``AllTypesNonNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``AllTypesNonNull_meta``)

      static member create
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let x = ``AllTypesNonNull``(internalUseOnlyValue)
        x.SetValues(
          ``bigint``,
          ``binary``,
          ``bit``,
          ``char``,
          ``date``,
          ``datetime``,
          ``datetime2``,
          ``datetimeoffset``,
          ``decimal``,
          ``float``,
          ``image``,
          ``int``,
          ``money``,
          ``nchar``,
          ``ntext``,
          ``numeric``,
          ``nvarchar``,
          ``real``,
          ``smalldatetime``,
          ``smallint``,
          ``smallmoney``,
          ``text``,
          ``time``,
          ``tinyint``,
          ``uniqueidentifier``,
          ``varbinary``,
          ``varchar``,
          ``xml``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``AllTypesNonNull``(internalUseOnlyValue)
        x.SetValues(
          (^a: (member ``bigint``: int64) dto),
          (^a: (member ``binary``: byte []) dto),
          (^a: (member ``bit``: bool) dto),
          (^a: (member ``char``: string) dto),
          (^a: (member ``date``: DateTime) dto),
          (^a: (member ``datetime``: DateTime) dto),
          (^a: (member ``datetime2``: DateTime) dto),
          (^a: (member ``datetimeoffset``: DateTimeOffset) dto),
          (^a: (member ``decimal``: decimal) dto),
          (^a: (member ``float``: float) dto),
          (^a: (member ``image``: byte []) dto),
          (^a: (member ``int``: int) dto),
          (^a: (member ``money``: decimal) dto),
          (^a: (member ``nchar``: string) dto),
          (^a: (member ``ntext``: string) dto),
          (^a: (member ``numeric``: decimal) dto),
          (^a: (member ``nvarchar``: string) dto),
          (^a: (member ``real``: float32) dto),
          (^a: (member ``smalldatetime``: DateTime) dto),
          (^a: (member ``smallint``: int16) dto),
          (^a: (member ``smallmoney``: decimal) dto),
          (^a: (member ``text``: string) dto),
          (^a: (member ``time``: TimeSpan) dto),
          (^a: (member ``tinyint``: byte) dto),
          (^a: (member ``uniqueidentifier``: Guid) dto),
          (^a: (member ``varbinary``: byte []) dto),
          (^a: (member ``varchar``: string) dto),
          (^a: (member ``xml``: string) dto)
        )
        |> ignore
        x


    let private ``AllTypesNull_meta`` = 
      [|
        SqlMetaData("bigint", SqlDbType.BigInt)
        SqlMetaData("binary", SqlDbType.Binary, 42L)
        SqlMetaData("bit", SqlDbType.Bit)
        SqlMetaData("char", SqlDbType.Char, 42L)
        SqlMetaData("date", SqlDbType.Date)
        SqlMetaData("datetime", SqlDbType.DateTime)
        SqlMetaData("datetime2", SqlDbType.DateTime2, 0uy, 3uy)
        SqlMetaData("datetimeoffset", SqlDbType.DateTimeOffset, 0uy, 1uy)
        SqlMetaData("decimal", SqlDbType.Decimal, 10uy, 5uy)
        SqlMetaData("float", SqlDbType.Float)
        SqlMetaData("image", SqlDbType.Image)
        SqlMetaData("int", SqlDbType.Int)
        SqlMetaData("money", SqlDbType.Money)
        SqlMetaData("nchar", SqlDbType.NChar, 42L)
        SqlMetaData("ntext", SqlDbType.NText)
        SqlMetaData("numeric", SqlDbType.Decimal, 8uy, 3uy)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 42L)
        SqlMetaData("real", SqlDbType.Real)
        SqlMetaData("smalldatetime", SqlDbType.SmallDateTime)
        SqlMetaData("smallint", SqlDbType.SmallInt)
        SqlMetaData("smallmoney", SqlDbType.SmallMoney)
        SqlMetaData("text", SqlDbType.Text)
        SqlMetaData("time", SqlDbType.Time, 0uy, 1uy)
        SqlMetaData("tinyint", SqlDbType.TinyInt)
        SqlMetaData("uniqueidentifier", SqlDbType.UniqueIdentifier)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 42L)
        SqlMetaData("varchar", SqlDbType.VarChar, 42L)
        SqlMetaData("xml", SqlDbType.Xml)
      |]


    type ``AllTypesNull`` (__: InternalUseOnly) =
      inherit SqlDataRecord (``AllTypesNull_meta``)

      static member create
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let x = ``AllTypesNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull ``bigint``,
          Option.toDbNull ``binary``,
          Option.toDbNull ``bit``,
          Option.toDbNull ``char``,
          Option.toDbNull ``date``,
          Option.toDbNull ``datetime``,
          Option.toDbNull ``datetime2``,
          Option.toDbNull ``datetimeoffset``,
          Option.toDbNull ``decimal``,
          Option.toDbNull ``float``,
          Option.toDbNull ``image``,
          Option.toDbNull ``int``,
          Option.toDbNull ``money``,
          Option.toDbNull ``nchar``,
          Option.toDbNull ``ntext``,
          Option.toDbNull ``numeric``,
          Option.toDbNull ``nvarchar``,
          Option.toDbNull ``real``,
          Option.toDbNull ``smalldatetime``,
          Option.toDbNull ``smallint``,
          Option.toDbNull ``smallmoney``,
          Option.toDbNull ``text``,
          Option.toDbNull ``time``,
          Option.toDbNull ``tinyint``,
          Option.toDbNull ``uniqueidentifier``,
          Option.toDbNull ``varbinary``,
          Option.toDbNull ``varchar``,
          Option.toDbNull ``xml``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``AllTypesNull``(internalUseOnlyValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``bigint``: int64 option) dto),
          Option.toDbNull (^a: (member ``binary``: byte [] option) dto),
          Option.toDbNull (^a: (member ``bit``: bool option) dto),
          Option.toDbNull (^a: (member ``char``: string option) dto),
          Option.toDbNull (^a: (member ``date``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetime``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetime2``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetimeoffset``: DateTimeOffset option) dto),
          Option.toDbNull (^a: (member ``decimal``: decimal option) dto),
          Option.toDbNull (^a: (member ``float``: float option) dto),
          Option.toDbNull (^a: (member ``image``: byte [] option) dto),
          Option.toDbNull (^a: (member ``int``: int option) dto),
          Option.toDbNull (^a: (member ``money``: decimal option) dto),
          Option.toDbNull (^a: (member ``nchar``: string option) dto),
          Option.toDbNull (^a: (member ``ntext``: string option) dto),
          Option.toDbNull (^a: (member ``numeric``: decimal option) dto),
          Option.toDbNull (^a: (member ``nvarchar``: string option) dto),
          Option.toDbNull (^a: (member ``real``: float32 option) dto),
          Option.toDbNull (^a: (member ``smalldatetime``: DateTime option) dto),
          Option.toDbNull (^a: (member ``smallint``: int16 option) dto),
          Option.toDbNull (^a: (member ``smallmoney``: decimal option) dto),
          Option.toDbNull (^a: (member ``text``: string option) dto),
          Option.toDbNull (^a: (member ``time``: TimeSpan option) dto),
          Option.toDbNull (^a: (member ``tinyint``: byte option) dto),
          Option.toDbNull (^a: (member ``uniqueidentifier``: Guid option) dto),
          Option.toDbNull (^a: (member ``varbinary``: byte [] option) dto),
          Option.toDbNull (^a: (member ``varchar``: string option) dto),
          Option.toDbNull (^a: (member ``xml``: string option) dto)
        )
        |> ignore
        x


module Procedures =


  module ``dbo`` =


    type ``ProcInsert`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcInsert"
        userConfigureCmd cmd

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcInsert``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcInsert``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeNonQuery connStr conn this.configureConn (configureCmd this.userConfigureCmd) []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionIn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionIn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcOptionIn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionIn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionIn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcOptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcOptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcOptionOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcOptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcOptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcOptionTableOutWithDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTableOutWithDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.OptionTableWithDto =
        {
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionTableOutWithDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcOptionTableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTableOutWithoutDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        {|
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionTableOutWithoutDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionTvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTvpInOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcOptionTvpInOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionTvpInOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``tvp``)
          |]
        ``ProcOptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcOptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcSelectFromTable`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcSelectFromTable"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
        {
          ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
          ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcSelectFromTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcSelectFromTable``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcSelectFromTableExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcSelectFromTableExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
        {
          ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
          ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcSelectFromTableExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcSelectFromTableExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcToBeModified`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcToBeModified"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcToBeModified``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcToBeModified``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionIn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionIn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcVoptionIn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionIn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionIn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string voption
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull ``param1``)
          |]
        ``ProcVoptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull (^a: (member ``Param1``: string voption) dto))
          |]
        ``ProcVoptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then ValueNone else reader.GetString 0 |> ValueSome

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcVoptionOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcVoptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcVoptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcVoptionTableOutWithDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTableOutWithDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.VoptionTableWithDto =
        {
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionTableOutWithDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcVoptionTableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTableOutWithoutDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        {|
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionTableOutWithoutDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionTvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTvpInOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then ValueNone else reader.GetInt32 ``ordinal_Foo`` |> ValueSome
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then ValueNone else reader.GetString ``ordinal_Bar`` |> ValueSome
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcVoptionTvpInOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionTvpInOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MultiColNullVoption``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = ``tvp``)
          |]
        ``ProcVoptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNullVoption``>) dto))
          |]
        ``ProcVoptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypes"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypes`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypes``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypes``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
            SqlParameter("@image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
            SqlParameter("@int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
            SqlParameter("@money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = (^a: (member ``Rowversion``: byte []) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
            SqlParameter("@text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = (^a: (member ``Timestamp``: byte []) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
          |]
        ``ProcWithAllTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypesExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
            SqlParameter("@image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
            SqlParameter("@int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
            SqlParameter("@money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = (^a: (member ``Rowversion``: byte []) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
            SqlParameter("@text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = (^a: (member ``Timestamp``: byte []) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
          |]
        ``ProcWithAllTypesExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = reader.GetInt64 ``ordinal_bigint``
          ``binary`` = reader.GetBytes ``ordinal_binary``
          ``bit`` = reader.GetBoolean ``ordinal_bit``
          ``char`` = reader.GetString ``ordinal_char``
          ``date`` = reader.GetDateTime ``ordinal_date``
          ``datetime`` = reader.GetDateTime ``ordinal_datetime``
          ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
          ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
          ``decimal`` = reader.GetDecimal ``ordinal_decimal``
          ``float`` = reader.GetDouble ``ordinal_float``
          ``image`` = reader.GetBytes ``ordinal_image``
          ``int`` = reader.GetInt32 ``ordinal_int``
          ``money`` = reader.GetDecimal ``ordinal_money``
          ``nchar`` = reader.GetString ``ordinal_nchar``
          ``ntext`` = reader.GetString ``ordinal_ntext``
          ``numeric`` = reader.GetDecimal ``ordinal_numeric``
          ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
          ``real`` = reader.GetFloat ``ordinal_real``
          ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
          ``smallint`` = reader.GetInt16 ``ordinal_smallint``
          ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
          ``text`` = reader.GetString ``ordinal_text``
          ``time`` = reader.GetTimeSpan ``ordinal_time``
          ``tinyint`` = reader.GetByte ``ordinal_tinyint``
          ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
          ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
          ``varchar`` = reader.GetString ``ordinal_varchar``
          ``xml`` = reader.GetString ``ordinal_xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesFromTvpNonNull`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNonNull``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNonNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = reader.GetInt64 ``ordinal_bigint``
          ``binary`` = reader.GetBytes ``ordinal_binary``
          ``bit`` = reader.GetBoolean ``ordinal_bit``
          ``char`` = reader.GetString ``ordinal_char``
          ``date`` = reader.GetDateTime ``ordinal_date``
          ``datetime`` = reader.GetDateTime ``ordinal_datetime``
          ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
          ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
          ``decimal`` = reader.GetDecimal ``ordinal_decimal``
          ``float`` = reader.GetDouble ``ordinal_float``
          ``image`` = reader.GetBytes ``ordinal_image``
          ``int`` = reader.GetInt32 ``ordinal_int``
          ``money`` = reader.GetDecimal ``ordinal_money``
          ``nchar`` = reader.GetString ``ordinal_nchar``
          ``ntext`` = reader.GetString ``ordinal_ntext``
          ``numeric`` = reader.GetDecimal ``ordinal_numeric``
          ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
          ``real`` = reader.GetFloat ``ordinal_real``
          ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
          ``smallint`` = reader.GetInt16 ``ordinal_smallint``
          ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
          ``text`` = reader.GetString ``ordinal_text``
          ``time`` = reader.GetTimeSpan ``ordinal_time``
          ``tinyint`` = reader.GetByte ``ordinal_tinyint``
          ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
          ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
          ``varchar`` = reader.GetString ``ordinal_varchar``
          ``xml`` = reader.GetString ``ordinal_xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesFromTvpNonNullExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNullExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNonNullExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNonNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNonNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesFromTvpNull`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNull``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesFromTvpNullExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNullExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNullExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesNull`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesNull``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Rowversion``: byte [] option) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Timestamp``: byte [] option) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
          |]
        ``ProcWithAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithAllTypesNullExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNullExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesNullExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Rowversion``: byte [] option) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Timestamp``: byte [] option) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
          |]
        ``ProcWithAllTypesNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithLengthTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithLengthTypes"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

      let getItem (reader: SqlDataReader) =
        {|
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithLengthTypes`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithLengthTypes``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithLengthTypes``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@binary", SqlDbType.Binary, Size = 3, Value = ``binary``)
            SqlParameter("@char", SqlDbType.Char, Size = 3, Value = ``char``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 3, Value = ``nchar``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 3, Value = ``nvarchar``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 3, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 3, Value = ``varchar``)
          |]
        ``ProcWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@binary", SqlDbType.Binary, Size = 3, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 3, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 3, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 3, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 3, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 3, Value = (^a: (member ``Varchar``: string) dto))
          |]
        ``ProcWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithLengthTypesFromTvp_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithLengthTypesFromTvp"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

      let getItem (reader: SqlDataReader) =
        {|
          ``binary`` = reader.GetBytes ``ordinal_binary``
          ``char`` = reader.GetString ``ordinal_char``
          ``nchar`` = reader.GetString ``ordinal_nchar``
          ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
          ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
          ``varchar`` = reader.GetString ``ordinal_varchar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithLengthTypesFromTvp`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithLengthTypesFromTvp``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithLengthTypesFromTvp``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``LengthTypes``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.LengthTypes", Value = ``tvp``)
          |]
        ``ProcWithLengthTypesFromTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.LengthTypes", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``LengthTypes``>) dto))
          |]
        ``ProcWithLengthTypesFromTvp_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcWithMultipleColumnsAndNoParams`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndNoParams"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndNoParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndNoParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcWithMultipleColumnsAndNoParamsExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndNoParamsExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndNoParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndNoParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleDefaultParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndSimpleDefaultParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleDefaultParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleDefaultParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleDefaultParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNonDefaultParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNullParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNullParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndSimpleNullParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNullParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNullParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option,
          ``bar``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Bar``: string option) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNullParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndSimpleNullParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option,
          ``bar``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Bar``: string option) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndTvpParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndTvpParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndTvpParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndTvpParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndTvpParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNonNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = ``multi``)
          |]
        ``ProcWithMultipleColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNonNull``>) dto))
          |]
        ``ProcWithMultipleColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndTvpParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleColumnsAndTvpParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndTvpParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndTvpParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNonNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = ``multi``)
          |]
        ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNonNull``>) dto))
          |]
        ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleNullableColumnsAndTvpParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleNullableColumnsAndTvpParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleNullableColumnsAndTvpParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleNullableColumnsAndTvpParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleNullableColumnsAndTvpParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``multi``)
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleNullableColumnsAndTvpParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithMultipleNullableColumnsAndTvpParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``multi``)
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNoResults_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNoResults"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData


    type ``ProcWithNoResults`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNoResults``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNoResults``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithNoResults_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithNoResults_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNoResultsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNoResultsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData


    type ``ProcWithNoResultsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNoResultsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNoResultsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithNoResultsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithNoResultsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcWithNonFSharpFriendlyNames`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNonFSharpFriendlyNames"
        userConfigureCmd cmd

      let mutable ``ordinal_This is the first column`` = 0
      let mutable ``ordinal_!"#%&/()=?`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_This is the first column`` <- reader.GetOrdinal "This is the first column"
        ``ordinal_!"#%&/()=?`` <- reader.GetOrdinal "!\"#%&/()=?"

      let getItem (reader: SqlDataReader) =
        {|
          ``This is the first column`` = reader.GetString ``ordinal_This is the first column``
          ``!"#%&/()=?`` = reader.GetInt32 ``ordinal_!"#%&/()=?``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNonFSharpFriendlyNames``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNonFSharpFriendlyNames``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcWithNonFSharpFriendlyNamesExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNonFSharpFriendlyNamesExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_This is the first column`` = 0
      let mutable ``ordinal_!"#%&/()=?`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_This is the first column`` <- reader.GetOrdinal "This is the first column"
        ``ordinal_!"#%&/()=?`` <- reader.GetOrdinal "!\"#%&/()=?"

      let getItem (reader: SqlDataReader) =
        {|
          ``This is the first column`` = reader.GetString ``ordinal_This is the first column``
          ``!"#%&/()=?`` = reader.GetInt32 ``ordinal_!"#%&/()=?``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNonFSharpFriendlyNamesExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNonFSharpFriendlyNamesExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithOutParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsAndRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsAndRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsAndRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsAndRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetValVoption_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetValVoption"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then ValueNone else sqlParams.[1].Value |> unbox<int> |> ValueSome
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then ValueNone else sqlParams.[3].Value |> unbox<string> |> ValueSome
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsAndRetValVoption`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetValVoption``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsAndRetValVoption``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string voption
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map ValueOption.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = ValueOption.toDbNull (^a: (member ``Out1``: int voption) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = ValueOption.toDbNull (^a: (member ``Out2``: string voption) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOverriddenDtoParamName_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOverriddenDtoParamName"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithOverriddenDtoParamName`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOverriddenDtoParamName``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOverriddenDtoParamName``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``nameToBeOverridden``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = ``nameToBeOverridden``)
          |]
        ``ProcWithOverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = (^a: (member ``newDtoParamName``: int) dto))
          |]
        ``ProcWithOverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithResultsAndOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithResultsAndOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParamsAndRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsAndRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParamsAndRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParamsAndRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsAndRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParamsAndRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithResultsAndOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithResultsAndOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd tempTableData (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd tempTableData
        |> wrapResultWithOutParams


    type ``ProcWithRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcWithSingleColumnAndNoParams`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleColumnAndNoParams"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleColumnAndNoParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleColumnAndNoParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcWithSingleColumnAndNoParamsExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleColumnAndNoParamsExtended"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleColumnAndNoParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleColumnAndNoParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcWithSingleNamelessColumn`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNamelessColumn"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNamelessColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNamelessColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcWithSingleNamelessColumnExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNamelessColumnExtended"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNamelessColumnExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNamelessColumnExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNonNullColumn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNonNullColumn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithSingleNonNullColumn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNonNullColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNonNullColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithSingleNonNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithSingleNonNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNonNullColumnExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNonNullColumnExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithSingleNonNullColumnExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNonNullColumnExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNonNullColumnExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithSingleNonNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithSingleNonNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNullColumn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNullColumn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithSingleNullColumn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNullColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNullColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
          |]
        ``ProcWithSingleNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
          |]
        ``ProcWithSingleNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNullColumnExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNullColumnExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithSingleNullColumnExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNullColumnExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNullColumnExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
          |]
        ``ProcWithSingleNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
          |]
        ``ProcWithSingleNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    type ``ProcWithSingleRecordCol`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleRecordCol"
        userConfigureCmd cmd

      let mutable ``ordinal_Test`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Test`` <- reader.GetOrdinal "Test"

      let getItem (reader: SqlDataReader) =
        {|
          ``Test`` = reader.GetInt32 ``ordinal_Test``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleRecordCol``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleRecordCol``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    type ``ProcWithSkippedUnsupportedColumn`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSkippedUnsupportedColumn"
        userConfigureCmd cmd

      let mutable ``ordinal_SupportedCol1`` = 0
      let mutable ``ordinal_SupportedCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_SupportedCol1`` <- reader.GetOrdinal "SupportedCol1"
        ``ordinal_SupportedCol2`` <- reader.GetOrdinal "SupportedCol2"

      let getItem (reader: SqlDataReader) =
        {|
          ``SupportedCol1`` = reader.GetInt32 ``ordinal_SupportedCol1``
          ``SupportedCol2`` = reader.GetString ``ordinal_SupportedCol2``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSkippedUnsupportedColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSkippedUnsupportedColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSpecialCasing_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSpecialCasing"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_COL1`` = 0
      let mutable ``ordinal_Col2`` = 0
      let mutable ``ordinal_col3`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_COL1`` <- reader.GetOrdinal "COL1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
        ``ordinal_col3`` <- reader.GetOrdinal "col3"

      let getItem (reader: SqlDataReader) =
        {|
          ``COL1`` = if reader.IsDBNull ``ordinal_COL1`` then None else reader.GetInt32 ``ordinal_COL1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          ``col3`` = if reader.IsDBNull ``ordinal_col3`` then None else reader.GetInt32 ``ordinal_col3`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithSpecialCasing`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSpecialCasing``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSpecialCasing``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``PARAM1``: int,
          ``Param2``: int,
          ``param3``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = ``PARAM1``)
            SqlParameter("@Param2", SqlDbType.Int, Value = ``Param2``)
            SqlParameter("@param3", SqlDbType.Int, Value = ``param3``)
          |]
        ``ProcWithSpecialCasing_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = (^a: (member ``PARAM1``: int) dto))
            SqlParameter("@Param2", SqlDbType.Int, Value = (^a: (member ``Param2``: int) dto))
            SqlParameter("@param3", SqlDbType.Int, Value = (^a: (member ``Param3``: int) dto))
          |]
        ``ProcWithSpecialCasing_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSpecialCasingExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSpecialCasingExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_COL1`` = 0
      let mutable ``ordinal_Col2`` = 0
      let mutable ``ordinal_col3`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_COL1`` <- reader.GetOrdinal "COL1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
        ``ordinal_col3`` <- reader.GetOrdinal "col3"

      let getItem (reader: SqlDataReader) =
        {|
          ``COL1`` = if reader.IsDBNull ``ordinal_COL1`` then None else reader.GetInt32 ``ordinal_COL1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          ``col3`` = if reader.IsDBNull ``ordinal_col3`` then None else reader.GetInt32 ``ordinal_col3`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


    type ``ProcWithSpecialCasingExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSpecialCasingExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSpecialCasingExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``PARAM1``: int,
          ``Param2``: int,
          ``param3``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = ``PARAM1``)
            SqlParameter("@Param2", SqlDbType.Int, Value = ``Param2``)
            SqlParameter("@param3", SqlDbType.Int, Value = ``param3``)
          |]
        ``ProcWithSpecialCasingExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = (^a: (member ``PARAM1``: int) dto))
            SqlParameter("@Param2", SqlDbType.Int, Value = (^a: (member ``Param2``: int) dto))
            SqlParameter("@param3", SqlDbType.Int, Value = (^a: (member ``Param3``: int) dto))
          |]
        ``ProcWithSpecialCasingExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


module Scripts =


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlWithDeclaration_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        DECLARE @_col1Filter NVARCHAR(42) = @col1Filter

        DECLARE @sql NVARCHAR(MAX) =
          'SELECT * FROM dbo.Table1 WHERE TableCol1 = @col1Filter'

        DECLARE @paramList NVARCHAR(MAX) =
          '@col1Filter NVARCHAR(42)'

        EXEC sp_executesql @sql, @paramList, @_col1Filter

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
      {
        ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      }

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``DynamicSqlWithDeclaration`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithDeclaration``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``DynamicSqlWithDeclaration``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1Filter``: string
      ) =
      let sqlParams =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = ``col1Filter``)
        |]
      ``DynamicSqlWithDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1Filter``: string) dto))
        |]
      ``DynamicSqlWithDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``DynamicSqlWithoutDeclaration_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        DECLARE @sql NVARCHAR(MAX) =
          'SELECT * FROM dbo.Table1 WHERE TableCol1 = @col1Filter'

        DECLARE @paramList NVARCHAR(MAX) =
          '@col1Filter NVARCHAR(42)'

        EXEC sp_executesql @sql, @paramList, @col1Filter

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
      {
        ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      }

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``DynamicSqlWithoutDeclaration`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``DynamicSqlWithoutDeclaration``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``DynamicSqlWithoutDeclaration``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1Filter``: string
      ) =
      let sqlParams =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = ``col1Filter``)
        |]
      ``DynamicSqlWithoutDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1Filter``: string) dto))
        |]
      ``DynamicSqlWithoutDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``MultipleTempTables_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT
          t1.Col1,
          t1.Col2,
          t2.Col3
        FROM
          #tempTable1 t1
        INNER JOIN
          #tempTable2 t2
            ON t2.Col1 = t1.Col1

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0
    let mutable ``ordinal_Col3`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
      ``ordinal_Col3`` <- reader.GetOrdinal "Col3"

    let getItem (reader: SqlDataReader) =
      {|
        ``Col1`` = reader.GetInt32 ``ordinal_Col1``
        ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
        ``Col3`` = reader.GetString ``ordinal_Col3``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``MultipleTempTables`` =


    type ``tempTable1`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTable1`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTable1``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTable1`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTable1``(internalUseOnlyValue, fields)


    type ``tempTable2`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col3``: string
        ) : ``tempTable2`` =
        [|
          ``Col1`` |> box
          ``Col3`` |> box
        |]
        |> fun fields -> ``tempTable2``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTable2`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          (^a: (member ``Col3``: string) dto) |> box
        |]
        |> fun fields -> ``tempTable2``(internalUseOnlyValue, fields)


  type ``MultipleTempTables`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``MultipleTempTables``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``MultipleTempTables``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTable1``: seq<``MultipleTempTables``.``tempTable1``>,
        ``tempTable2``: seq<``MultipleTempTables``.``tempTable2``>
      ) =
      [
        TempTableData
          (
            "#tempTable1",
            """
            CREATE TABLE #tempTable1 (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTable1`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
        TempTableData
          (
            "#tempTable2",
            """
            CREATE TABLE #tempTable2 (Col1 INT NOT NULL, Col3 NVARCHAR(42) NOT NULL)
            """,
            (``tempTable2`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTable1``: seq<``MultipleTempTables``.``tempTable1``>,
        ``tempTable2``: seq<``MultipleTempTables``.``tempTable2``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTable1``,
          ``tempTable2``
        )
      ``MultipleTempTables_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTable1``: #seq<``MultipleTempTables``.``tempTable1``>) dto),
          (^a: (member ``TempTable2``: #seq<``MultipleTempTables``.``tempTable2``>) dto)
        )
      ``MultipleTempTables_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``NormalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM Table1 WHERE TableCol1 = @col1

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
      {
        ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      }

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``NormalParams`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``NormalParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``NormalParams``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1``: string
      ) =
      let sqlParams =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 42, Value = ``col1``)
        |]
      ``NormalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1``: string) dto))
        |]
      ``NormalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``OptionRecompileAndFetch_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        -- Use an extended sproc to force sp_describe_first_result_set to fail
        -- and parser to fallback to SET FMTONLY ON
        EXEC sp_getapplock 'TestLock', 'Update'

        SELECT
          *
        FROM
          Table1
        ORDER BY
          TableCol1
        OFFSET @offset ROWS
        FETCH NEXT @limit ROWS ONLY

        -- Together with FETCH above, this will for some reason cause SET FMTONLY ON to fail if --
        -- @limit is NULL, meaning that the parameter will have to be added with an actual value even
        -- for SET FMTONLY ON
        OPTION (RECOMPILE)

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
      {
        ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      }

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``OptionRecompileAndFetch`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``OptionRecompileAndFetch``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``OptionRecompileAndFetch``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``offset``: int64,
        ``limit``: int64
      ) =
      let sqlParams =
        [|
          SqlParameter("@offset", SqlDbType.BigInt, Value = ``offset``)
          SqlParameter("@limit", SqlDbType.BigInt, Value = ``limit``)
        |]
      ``OptionRecompileAndFetch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@offset", SqlDbType.BigInt, Value = (^a: (member ``Offset``: int64) dto))
          SqlParameter("@limit", SqlDbType.BigInt, Value = (^a: (member ``Limit``: int64) dto))
        |]
      ``OptionRecompileAndFetch_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``OverriddenDtoParamName_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT @nameToBeOverridden

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let initOrdinals = ignore<SqlDataReader>

    let getItem (reader: SqlDataReader) =
      if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``OverriddenDtoParamName`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``OverriddenDtoParamName``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``OverriddenDtoParamName``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``nameToBeOverridden``: int
      ) =
      let sqlParams =
        [|
          SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = ``nameToBeOverridden``)
        |]
      ``OverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = (^a: (member ``newDtoParamName``: int) dto))
        |]
      ``OverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``ParamsUsedTwice_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM Table1 WHERE TableCol1 = @col1 AND TableCol1 = @col1

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
      {
        ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      }

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``ParamsUsedTwice`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``ParamsUsedTwice``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``ParamsUsedTwice``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``col1``: string option
      ) =
      let sqlParams =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``col1``)
        |]
      ``ParamsUsedTwice_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@col1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Col1``: string option) dto))
        |]
      ``ParamsUsedTwice_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  type ``SelectAllFromTable`` private (connStr: string, conn: SqlConnection) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM Table1

      """
      userConfigureCmd cmd

    let mutable ``ordinal_TableCol1`` = 0
    let mutable ``ordinal_TableCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
      ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
      {
        ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
        ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
      }

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``SelectAllFromTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``SelectAllFromTable``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    #endif

    member this.LazyExecute() =
      executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


  type ``SingleRecordCol`` private (connStr: string, conn: SqlConnection) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT Test = 1

      """
      userConfigureCmd cmd

    let mutable ``ordinal_Test`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Test`` <- reader.GetOrdinal "Test"

    let getItem (reader: SqlDataReader) =
      {|
        ``Test`` = reader.GetInt32 ``ordinal_Test``
      |}

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``SingleRecordCol``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``SingleRecordCol``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    #endif

    member this.LazyExecute() =
      executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


  type ``SkippedUnsupportedColumn`` private (connStr: string, conn: SqlConnection) =

    let configureCmd userConfigureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        DECLARE @hid HIERARCHYID

        SELECT
          SupportedCol1 = 1,
          SupportedCol2 = 'test',
          UnsupportedCol = @hid

      """
      userConfigureCmd cmd

    let mutable ``ordinal_SupportedCol1`` = 0
    let mutable ``ordinal_SupportedCol2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_SupportedCol1`` <- reader.GetOrdinal "SupportedCol1"
      ``ordinal_SupportedCol2`` <- reader.GetOrdinal "SupportedCol2"

    let getItem (reader: SqlDataReader) =
      {|
        ``SupportedCol1`` = reader.GetInt32 ``ordinal_SupportedCol1``
        ``SupportedCol2`` = reader.GetString ``ordinal_SupportedCol2``
      |}

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``SkippedUnsupportedColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``SkippedUnsupportedColumn``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member this.Execute() =
      executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member this.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    #endif

    member this.LazyExecute() =
      executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

    member this.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member this.ExecuteSingle() =
      executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNonNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM #AllTypesNonNull

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      {|
        ``Bigint`` = reader.GetInt64 ``ordinal_Bigint``
        ``Binary`` = reader.GetBytes ``ordinal_Binary``
        ``Bit`` = reader.GetBoolean ``ordinal_Bit``
        ``Char`` = reader.GetString ``ordinal_Char``
        ``Date`` = reader.GetDateTime ``ordinal_Date``
        ``Datetime`` = reader.GetDateTime ``ordinal_Datetime``
        ``Datetime2`` = reader.GetDateTime ``ordinal_Datetime2``
        ``Datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_Datetimeoffset``
        ``Decimal`` = reader.GetDecimal ``ordinal_Decimal``
        ``Float`` = reader.GetDouble ``ordinal_Float``
        ``Image`` = reader.GetBytes ``ordinal_Image``
        ``Int`` = reader.GetInt32 ``ordinal_Int``
        ``Money`` = reader.GetDecimal ``ordinal_Money``
        ``Nchar`` = reader.GetString ``ordinal_Nchar``
        ``Ntext`` = reader.GetString ``ordinal_Ntext``
        ``Numeric`` = reader.GetDecimal ``ordinal_Numeric``
        ``Nvarchar`` = reader.GetString ``ordinal_Nvarchar``
        ``Real`` = reader.GetFloat ``ordinal_Real``
        ``Smalldatetime`` = reader.GetDateTime ``ordinal_Smalldatetime``
        ``Smallint`` = reader.GetInt16 ``ordinal_Smallint``
        ``Smallmoney`` = reader.GetDecimal ``ordinal_Smallmoney``
        ``Text`` = reader.GetString ``ordinal_Text``
        ``Time`` = reader.GetTimeSpan ``ordinal_Time``
        ``Tinyint`` = reader.GetByte ``ordinal_Tinyint``
        ``Uniqueidentifier`` = reader.GetGuid ``ordinal_Uniqueidentifier``
        ``Varbinary`` = reader.GetBytes ``ordinal_Varbinary``
        ``Varchar`` = reader.GetString ``ordinal_Varchar``
        ``Xml`` = reader.GetString ``ordinal_Xml``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableAllTypesNonNull`` =


    type ``AllTypesNonNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64,
          ``Binary``: byte [],
          ``Bit``: bool,
          ``Char``: string,
          ``Date``: DateTime,
          ``Datetime``: DateTime,
          ``Datetime2``: DateTime,
          ``Datetimeoffset``: DateTimeOffset,
          ``Decimal``: decimal,
          ``Float``: float,
          ``Image``: byte [],
          ``Int``: int,
          ``Money``: decimal,
          ``Nchar``: string,
          ``Ntext``: string,
          ``Numeric``: decimal,
          ``Nvarchar``: string,
          ``Real``: float32,
          ``Smalldatetime``: DateTime,
          ``Smallint``: int16,
          ``Smallmoney``: decimal,
          ``Text``: string,
          ``Time``: TimeSpan,
          ``Tinyint``: byte,
          ``Uniqueidentifier``: Guid,
          ``Varbinary``: byte [],
          ``Varchar``: string,
          ``Xml``: string
        ) : ``AllTypesNonNull`` =
        [|
          ``Bigint`` |> box
          ``Binary`` |> box
          ``Bit`` |> box
          ``Char`` |> box
          ``Date`` |> box
          ``Datetime`` |> box
          ``Datetime2`` |> box
          ``Datetimeoffset`` |> box
          ``Decimal`` |> box
          ``Float`` |> box
          ``Image`` |> box
          ``Int`` |> box
          ``Money`` |> box
          ``Nchar`` |> box
          ``Ntext`` |> box
          ``Numeric`` |> box
          ``Nvarchar`` |> box
          ``Real`` |> box
          ``Smalldatetime`` |> box
          ``Smallint`` |> box
          ``Smallmoney`` |> box
          ``Text`` |> box
          ``Time`` |> box
          ``Tinyint`` |> box
          ``Uniqueidentifier`` |> box
          ``Varbinary`` |> box
          ``Varchar`` |> box
          ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNonNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNonNull`` =
        [|
          (^a: (member ``Bigint``: int64) dto) |> box
          (^a: (member ``Binary``: byte []) dto) |> box
          (^a: (member ``Bit``: bool) dto) |> box
          (^a: (member ``Char``: string) dto) |> box
          (^a: (member ``Date``: DateTime) dto) |> box
          (^a: (member ``Datetime``: DateTime) dto) |> box
          (^a: (member ``Datetime2``: DateTime) dto) |> box
          (^a: (member ``Datetimeoffset``: DateTimeOffset) dto) |> box
          (^a: (member ``Decimal``: decimal) dto) |> box
          (^a: (member ``Float``: float) dto) |> box
          (^a: (member ``Image``: byte []) dto) |> box
          (^a: (member ``Int``: int) dto) |> box
          (^a: (member ``Money``: decimal) dto) |> box
          (^a: (member ``Nchar``: string) dto) |> box
          (^a: (member ``Ntext``: string) dto) |> box
          (^a: (member ``Numeric``: decimal) dto) |> box
          (^a: (member ``Nvarchar``: string) dto) |> box
          (^a: (member ``Real``: float32) dto) |> box
          (^a: (member ``Smalldatetime``: DateTime) dto) |> box
          (^a: (member ``Smallint``: int16) dto) |> box
          (^a: (member ``Smallmoney``: decimal) dto) |> box
          (^a: (member ``Text``: string) dto) |> box
          (^a: (member ``Time``: TimeSpan) dto) |> box
          (^a: (member ``Tinyint``: byte) dto) |> box
          (^a: (member ``Uniqueidentifier``: Guid) dto) |> box
          (^a: (member ``Varbinary``: byte []) dto) |> box
          (^a: (member ``Varchar``: string) dto) |> box
          (^a: (member ``Xml``: string) dto) |> box
        |]
        |> fun fields -> ``AllTypesNonNull``(internalUseOnlyValue, fields)


  type ``TempTableAllTypesNonNull`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNonNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableAllTypesNonNull``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNonNull``: seq<``TempTableAllTypesNonNull``.``AllTypesNonNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNonNull",
            """
            CREATE TABLE #AllTypesNonNull (
              [Bigint] BIGINT NOT NULL,
              [Binary] BINARY(42) NOT NULL,
              [Bit] BIT NOT NULL,
              [Char] CHAR(42) NOT NULL,
              [Date] DATE NOT NULL,
              [Datetime] DATETIME NOT NULL,
              [Datetime2] DATETIME2(3) NOT NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NOT NULL,
              [Decimal] DECIMAL(10, 5) NOT NULL,
              [Float] FLOAT(42) NOT NULL,
              [Image] IMAGE NOT NULL,
              [Int] INT NOT NULL,
              [Money] MONEY NOT NULL,
              [Nchar] NCHAR(42) NOT NULL,
              [Ntext] NTEXT NOT NULL,
              [Numeric] NUMERIC(8, 3) NOT NULL,
              [Nvarchar] NVARCHAR(42) NOT NULL,
              [Real] REAL NOT NULL,
              [Smalldatetime] SMALLDATETIME NOT NULL,
              [Smallint] SMALLINT NOT NULL,
              [Smallmoney] SMALLMONEY NOT NULL,
              [Text] TEXT NOT NULL,
              [Time] TIME(1) NOT NULL,
              [Tinyint] TINYINT NOT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NOT NULL,
              [Varbinary] VARBINARY(42) NOT NULL,
              [Varchar] VARCHAR(42) NOT NULL,
              [Xml] XML NOT NULL
            )

            """,
            (``AllTypesNonNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNonNull``: seq<``TempTableAllTypesNonNull``.``AllTypesNonNull``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNonNull``
        )
      ``TempTableAllTypesNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``AllTypesNonNull``: #seq<``TempTableAllTypesNonNull``.``AllTypesNonNull``>) dto)
        )
      ``TempTableAllTypesNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM #AllTypesNull

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      {|
        ``Bigint`` = if reader.IsDBNull ``ordinal_Bigint`` then None else reader.GetInt64 ``ordinal_Bigint`` |> Some
        ``Binary`` = if reader.IsDBNull ``ordinal_Binary`` then None else reader.GetBytes ``ordinal_Binary`` |> Some
        ``Bit`` = if reader.IsDBNull ``ordinal_Bit`` then None else reader.GetBoolean ``ordinal_Bit`` |> Some
        ``Char`` = if reader.IsDBNull ``ordinal_Char`` then None else reader.GetString ``ordinal_Char`` |> Some
        ``Date`` = if reader.IsDBNull ``ordinal_Date`` then None else reader.GetDateTime ``ordinal_Date`` |> Some
        ``Datetime`` = if reader.IsDBNull ``ordinal_Datetime`` then None else reader.GetDateTime ``ordinal_Datetime`` |> Some
        ``Datetime2`` = if reader.IsDBNull ``ordinal_Datetime2`` then None else reader.GetDateTime ``ordinal_Datetime2`` |> Some
        ``Datetimeoffset`` = if reader.IsDBNull ``ordinal_Datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_Datetimeoffset`` |> Some
        ``Decimal`` = if reader.IsDBNull ``ordinal_Decimal`` then None else reader.GetDecimal ``ordinal_Decimal`` |> Some
        ``Float`` = if reader.IsDBNull ``ordinal_Float`` then None else reader.GetDouble ``ordinal_Float`` |> Some
        ``Image`` = if reader.IsDBNull ``ordinal_Image`` then None else reader.GetBytes ``ordinal_Image`` |> Some
        ``Int`` = if reader.IsDBNull ``ordinal_Int`` then None else reader.GetInt32 ``ordinal_Int`` |> Some
        ``Money`` = if reader.IsDBNull ``ordinal_Money`` then None else reader.GetDecimal ``ordinal_Money`` |> Some
        ``Nchar`` = if reader.IsDBNull ``ordinal_Nchar`` then None else reader.GetString ``ordinal_Nchar`` |> Some
        ``Ntext`` = if reader.IsDBNull ``ordinal_Ntext`` then None else reader.GetString ``ordinal_Ntext`` |> Some
        ``Numeric`` = if reader.IsDBNull ``ordinal_Numeric`` then None else reader.GetDecimal ``ordinal_Numeric`` |> Some
        ``Nvarchar`` = if reader.IsDBNull ``ordinal_Nvarchar`` then None else reader.GetString ``ordinal_Nvarchar`` |> Some
        ``Real`` = if reader.IsDBNull ``ordinal_Real`` then None else reader.GetFloat ``ordinal_Real`` |> Some
        ``Smalldatetime`` = if reader.IsDBNull ``ordinal_Smalldatetime`` then None else reader.GetDateTime ``ordinal_Smalldatetime`` |> Some
        ``Smallint`` = if reader.IsDBNull ``ordinal_Smallint`` then None else reader.GetInt16 ``ordinal_Smallint`` |> Some
        ``Smallmoney`` = if reader.IsDBNull ``ordinal_Smallmoney`` then None else reader.GetDecimal ``ordinal_Smallmoney`` |> Some
        ``Text`` = if reader.IsDBNull ``ordinal_Text`` then None else reader.GetString ``ordinal_Text`` |> Some
        ``Time`` = if reader.IsDBNull ``ordinal_Time`` then None else reader.GetTimeSpan ``ordinal_Time`` |> Some
        ``Tinyint`` = if reader.IsDBNull ``ordinal_Tinyint`` then None else reader.GetByte ``ordinal_Tinyint`` |> Some
        ``Uniqueidentifier`` = if reader.IsDBNull ``ordinal_Uniqueidentifier`` then None else reader.GetGuid ``ordinal_Uniqueidentifier`` |> Some
        ``Varbinary`` = if reader.IsDBNull ``ordinal_Varbinary`` then None else reader.GetBytes ``ordinal_Varbinary`` |> Some
        ``Varchar`` = if reader.IsDBNull ``ordinal_Varchar`` then None else reader.GetString ``ordinal_Varchar`` |> Some
        ``Xml`` = if reader.IsDBNull ``ordinal_Xml`` then None else reader.GetString ``ordinal_Xml`` |> Some
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableAllTypesNull`` =


    type ``AllTypesNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64 option,
          ``Binary``: byte [] option,
          ``Bit``: bool option,
          ``Char``: string option,
          ``Date``: DateTime option,
          ``Datetime``: DateTime option,
          ``Datetime2``: DateTime option,
          ``Datetimeoffset``: DateTimeOffset option,
          ``Decimal``: decimal option,
          ``Float``: float option,
          ``Image``: byte [] option,
          ``Int``: int option,
          ``Money``: decimal option,
          ``Nchar``: string option,
          ``Ntext``: string option,
          ``Numeric``: decimal option,
          ``Nvarchar``: string option,
          ``Real``: float32 option,
          ``Smalldatetime``: DateTime option,
          ``Smallint``: int16 option,
          ``Smallmoney``: decimal option,
          ``Text``: string option,
          ``Time``: TimeSpan option,
          ``Tinyint``: byte option,
          ``Uniqueidentifier``: Guid option,
          ``Varbinary``: byte [] option,
          ``Varchar``: string option,
          ``Xml``: string option
        ) : ``AllTypesNull`` =
        [|
          Option.toDbNull ``Bigint`` |> box
          Option.toDbNull ``Binary`` |> box
          Option.toDbNull ``Bit`` |> box
          Option.toDbNull ``Char`` |> box
          Option.toDbNull ``Date`` |> box
          Option.toDbNull ``Datetime`` |> box
          Option.toDbNull ``Datetime2`` |> box
          Option.toDbNull ``Datetimeoffset`` |> box
          Option.toDbNull ``Decimal`` |> box
          Option.toDbNull ``Float`` |> box
          Option.toDbNull ``Image`` |> box
          Option.toDbNull ``Int`` |> box
          Option.toDbNull ``Money`` |> box
          Option.toDbNull ``Nchar`` |> box
          Option.toDbNull ``Ntext`` |> box
          Option.toDbNull ``Numeric`` |> box
          Option.toDbNull ``Nvarchar`` |> box
          Option.toDbNull ``Real`` |> box
          Option.toDbNull ``Smalldatetime`` |> box
          Option.toDbNull ``Smallint`` |> box
          Option.toDbNull ``Smallmoney`` |> box
          Option.toDbNull ``Text`` |> box
          Option.toDbNull ``Time`` |> box
          Option.toDbNull ``Tinyint`` |> box
          Option.toDbNull ``Uniqueidentifier`` |> box
          Option.toDbNull ``Varbinary`` |> box
          Option.toDbNull ``Varchar`` |> box
          Option.toDbNull ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNull`` =
        [|
          Option.toDbNull (^a: (member ``Bigint``: int64 option) dto) |> box
          Option.toDbNull (^a: (member ``Binary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Bit``: bool option) dto) |> box
          Option.toDbNull (^a: (member ``Char``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Date``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto) |> box
          Option.toDbNull (^a: (member ``Decimal``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Float``: float option) dto) |> box
          Option.toDbNull (^a: (member ``Image``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Int``: int option) dto) |> box
          Option.toDbNull (^a: (member ``Money``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Nchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Ntext``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Numeric``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Nvarchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Real``: float32 option) dto) |> box
          Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto) |> box
          Option.toDbNull (^a: (member ``Smallint``: int16 option) dto) |> box
          Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto) |> box
          Option.toDbNull (^a: (member ``Text``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto) |> box
          Option.toDbNull (^a: (member ``Tinyint``: byte option) dto) |> box
          Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto) |> box
          Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto) |> box
          Option.toDbNull (^a: (member ``Varchar``: string option) dto) |> box
          Option.toDbNull (^a: (member ``Xml``: string option) dto) |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)


  type ``TempTableAllTypesNull`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableAllTypesNull``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNull``: seq<``TempTableAllTypesNull``.``AllTypesNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNull",
            """
            CREATE TABLE #AllTypesNull (
              [Bigint] BIGINT NULL,
              [Binary] BINARY(42) NULL,
              [Bit] BIT NULL,
              [Char] CHAR(42) NULL,
              [Date] DATE NULL,
              [Datetime] DATETIME NULL,
              [Datetime2] DATETIME2(3) NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NULL,
              [Decimal] DECIMAL(10, 5) NULL,
              [Float] FLOAT(42) NULL,
              [Image] IMAGE NULL,
              [Int] INT NULL,
              [Money] MONEY NULL,
              [Nchar] NCHAR(42) NULL,
              [Ntext] NTEXT NULL,
              [Numeric] NUMERIC(8, 3) NULL,
              [Nvarchar] NVARCHAR(42) NULL,
              [Real] REAL NULL,
              [Smalldatetime] SMALLDATETIME NULL,
              [Smallint] SMALLINT NULL,
              [Smallmoney] SMALLMONEY NULL,
              [Text] TEXT NULL,
              [Time] TIME(1) NULL,
              [Tinyint] TINYINT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [Varbinary] VARBINARY(42) NULL,
              [Varchar] VARCHAR(42) NULL,
              [Xml] XML NULL
            )

            """,
            (``AllTypesNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNull``: seq<``TempTableAllTypesNull``.``AllTypesNull``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNull``
        )
      ``TempTableAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``AllTypesNull``: #seq<``TempTableAllTypesNull``.``AllTypesNull``>) dto)
        )
      ``TempTableAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableAllTypesNullVoption_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM #AllTypesNull

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Bigint`` = 0
    let mutable ``ordinal_Binary`` = 0
    let mutable ``ordinal_Bit`` = 0
    let mutable ``ordinal_Char`` = 0
    let mutable ``ordinal_Date`` = 0
    let mutable ``ordinal_Datetime`` = 0
    let mutable ``ordinal_Datetime2`` = 0
    let mutable ``ordinal_Datetimeoffset`` = 0
    let mutable ``ordinal_Decimal`` = 0
    let mutable ``ordinal_Float`` = 0
    let mutable ``ordinal_Image`` = 0
    let mutable ``ordinal_Int`` = 0
    let mutable ``ordinal_Money`` = 0
    let mutable ``ordinal_Nchar`` = 0
    let mutable ``ordinal_Ntext`` = 0
    let mutable ``ordinal_Numeric`` = 0
    let mutable ``ordinal_Nvarchar`` = 0
    let mutable ``ordinal_Real`` = 0
    let mutable ``ordinal_Smalldatetime`` = 0
    let mutable ``ordinal_Smallint`` = 0
    let mutable ``ordinal_Smallmoney`` = 0
    let mutable ``ordinal_Text`` = 0
    let mutable ``ordinal_Time`` = 0
    let mutable ``ordinal_Tinyint`` = 0
    let mutable ``ordinal_Uniqueidentifier`` = 0
    let mutable ``ordinal_Varbinary`` = 0
    let mutable ``ordinal_Varchar`` = 0
    let mutable ``ordinal_Xml`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Bigint`` <- reader.GetOrdinal "Bigint"
      ``ordinal_Binary`` <- reader.GetOrdinal "Binary"
      ``ordinal_Bit`` <- reader.GetOrdinal "Bit"
      ``ordinal_Char`` <- reader.GetOrdinal "Char"
      ``ordinal_Date`` <- reader.GetOrdinal "Date"
      ``ordinal_Datetime`` <- reader.GetOrdinal "Datetime"
      ``ordinal_Datetime2`` <- reader.GetOrdinal "Datetime2"
      ``ordinal_Datetimeoffset`` <- reader.GetOrdinal "Datetimeoffset"
      ``ordinal_Decimal`` <- reader.GetOrdinal "Decimal"
      ``ordinal_Float`` <- reader.GetOrdinal "Float"
      ``ordinal_Image`` <- reader.GetOrdinal "Image"
      ``ordinal_Int`` <- reader.GetOrdinal "Int"
      ``ordinal_Money`` <- reader.GetOrdinal "Money"
      ``ordinal_Nchar`` <- reader.GetOrdinal "Nchar"
      ``ordinal_Ntext`` <- reader.GetOrdinal "Ntext"
      ``ordinal_Numeric`` <- reader.GetOrdinal "Numeric"
      ``ordinal_Nvarchar`` <- reader.GetOrdinal "Nvarchar"
      ``ordinal_Real`` <- reader.GetOrdinal "Real"
      ``ordinal_Smalldatetime`` <- reader.GetOrdinal "Smalldatetime"
      ``ordinal_Smallint`` <- reader.GetOrdinal "Smallint"
      ``ordinal_Smallmoney`` <- reader.GetOrdinal "Smallmoney"
      ``ordinal_Text`` <- reader.GetOrdinal "Text"
      ``ordinal_Time`` <- reader.GetOrdinal "Time"
      ``ordinal_Tinyint`` <- reader.GetOrdinal "Tinyint"
      ``ordinal_Uniqueidentifier`` <- reader.GetOrdinal "Uniqueidentifier"
      ``ordinal_Varbinary`` <- reader.GetOrdinal "Varbinary"
      ``ordinal_Varchar`` <- reader.GetOrdinal "Varchar"
      ``ordinal_Xml`` <- reader.GetOrdinal "Xml"

    let getItem (reader: SqlDataReader) =
      {|
        ``Bigint`` = if reader.IsDBNull ``ordinal_Bigint`` then None else reader.GetInt64 ``ordinal_Bigint`` |> Some
        ``Binary`` = if reader.IsDBNull ``ordinal_Binary`` then None else reader.GetBytes ``ordinal_Binary`` |> Some
        ``Bit`` = if reader.IsDBNull ``ordinal_Bit`` then None else reader.GetBoolean ``ordinal_Bit`` |> Some
        ``Char`` = if reader.IsDBNull ``ordinal_Char`` then None else reader.GetString ``ordinal_Char`` |> Some
        ``Date`` = if reader.IsDBNull ``ordinal_Date`` then None else reader.GetDateTime ``ordinal_Date`` |> Some
        ``Datetime`` = if reader.IsDBNull ``ordinal_Datetime`` then None else reader.GetDateTime ``ordinal_Datetime`` |> Some
        ``Datetime2`` = if reader.IsDBNull ``ordinal_Datetime2`` then None else reader.GetDateTime ``ordinal_Datetime2`` |> Some
        ``Datetimeoffset`` = if reader.IsDBNull ``ordinal_Datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_Datetimeoffset`` |> Some
        ``Decimal`` = if reader.IsDBNull ``ordinal_Decimal`` then None else reader.GetDecimal ``ordinal_Decimal`` |> Some
        ``Float`` = if reader.IsDBNull ``ordinal_Float`` then None else reader.GetDouble ``ordinal_Float`` |> Some
        ``Image`` = if reader.IsDBNull ``ordinal_Image`` then None else reader.GetBytes ``ordinal_Image`` |> Some
        ``Int`` = if reader.IsDBNull ``ordinal_Int`` then None else reader.GetInt32 ``ordinal_Int`` |> Some
        ``Money`` = if reader.IsDBNull ``ordinal_Money`` then None else reader.GetDecimal ``ordinal_Money`` |> Some
        ``Nchar`` = if reader.IsDBNull ``ordinal_Nchar`` then None else reader.GetString ``ordinal_Nchar`` |> Some
        ``Ntext`` = if reader.IsDBNull ``ordinal_Ntext`` then None else reader.GetString ``ordinal_Ntext`` |> Some
        ``Numeric`` = if reader.IsDBNull ``ordinal_Numeric`` then None else reader.GetDecimal ``ordinal_Numeric`` |> Some
        ``Nvarchar`` = if reader.IsDBNull ``ordinal_Nvarchar`` then None else reader.GetString ``ordinal_Nvarchar`` |> Some
        ``Real`` = if reader.IsDBNull ``ordinal_Real`` then None else reader.GetFloat ``ordinal_Real`` |> Some
        ``Smalldatetime`` = if reader.IsDBNull ``ordinal_Smalldatetime`` then None else reader.GetDateTime ``ordinal_Smalldatetime`` |> Some
        ``Smallint`` = if reader.IsDBNull ``ordinal_Smallint`` then None else reader.GetInt16 ``ordinal_Smallint`` |> Some
        ``Smallmoney`` = if reader.IsDBNull ``ordinal_Smallmoney`` then None else reader.GetDecimal ``ordinal_Smallmoney`` |> Some
        ``Text`` = if reader.IsDBNull ``ordinal_Text`` then None else reader.GetString ``ordinal_Text`` |> Some
        ``Time`` = if reader.IsDBNull ``ordinal_Time`` then None else reader.GetTimeSpan ``ordinal_Time`` |> Some
        ``Tinyint`` = if reader.IsDBNull ``ordinal_Tinyint`` then None else reader.GetByte ``ordinal_Tinyint`` |> Some
        ``Uniqueidentifier`` = if reader.IsDBNull ``ordinal_Uniqueidentifier`` then None else reader.GetGuid ``ordinal_Uniqueidentifier`` |> Some
        ``Varbinary`` = if reader.IsDBNull ``ordinal_Varbinary`` then None else reader.GetBytes ``ordinal_Varbinary`` |> Some
        ``Varchar`` = if reader.IsDBNull ``ordinal_Varchar`` then None else reader.GetString ``ordinal_Varchar`` |> Some
        ``Xml`` = if reader.IsDBNull ``ordinal_Xml`` then None else reader.GetString ``ordinal_Xml`` |> Some
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableAllTypesNullVoption`` =


    type ``AllTypesNull`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Bigint``: int64 voption,
          ``Binary``: byte [] voption,
          ``Bit``: bool voption,
          ``Char``: string voption,
          ``Date``: DateTime voption,
          ``Datetime``: DateTime voption,
          ``Datetime2``: DateTime voption,
          ``Datetimeoffset``: DateTimeOffset voption,
          ``Decimal``: decimal voption,
          ``Float``: float voption,
          ``Image``: byte [] voption,
          ``Int``: int voption,
          ``Money``: decimal voption,
          ``Nchar``: string voption,
          ``Ntext``: string voption,
          ``Numeric``: decimal voption,
          ``Nvarchar``: string voption,
          ``Real``: float32 voption,
          ``Smalldatetime``: DateTime voption,
          ``Smallint``: int16 voption,
          ``Smallmoney``: decimal voption,
          ``Text``: string voption,
          ``Time``: TimeSpan voption,
          ``Tinyint``: byte voption,
          ``Uniqueidentifier``: Guid voption,
          ``Varbinary``: byte [] voption,
          ``Varchar``: string voption,
          ``Xml``: string voption
        ) : ``AllTypesNull`` =
        [|
          ValueOption.toDbNull ``Bigint`` |> box
          ValueOption.toDbNull ``Binary`` |> box
          ValueOption.toDbNull ``Bit`` |> box
          ValueOption.toDbNull ``Char`` |> box
          ValueOption.toDbNull ``Date`` |> box
          ValueOption.toDbNull ``Datetime`` |> box
          ValueOption.toDbNull ``Datetime2`` |> box
          ValueOption.toDbNull ``Datetimeoffset`` |> box
          ValueOption.toDbNull ``Decimal`` |> box
          ValueOption.toDbNull ``Float`` |> box
          ValueOption.toDbNull ``Image`` |> box
          ValueOption.toDbNull ``Int`` |> box
          ValueOption.toDbNull ``Money`` |> box
          ValueOption.toDbNull ``Nchar`` |> box
          ValueOption.toDbNull ``Ntext`` |> box
          ValueOption.toDbNull ``Numeric`` |> box
          ValueOption.toDbNull ``Nvarchar`` |> box
          ValueOption.toDbNull ``Real`` |> box
          ValueOption.toDbNull ``Smalldatetime`` |> box
          ValueOption.toDbNull ``Smallint`` |> box
          ValueOption.toDbNull ``Smallmoney`` |> box
          ValueOption.toDbNull ``Text`` |> box
          ValueOption.toDbNull ``Time`` |> box
          ValueOption.toDbNull ``Tinyint`` |> box
          ValueOption.toDbNull ``Uniqueidentifier`` |> box
          ValueOption.toDbNull ``Varbinary`` |> box
          ValueOption.toDbNull ``Varchar`` |> box
          ValueOption.toDbNull ``Xml`` |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``AllTypesNull`` =
        [|
          ValueOption.toDbNull (^a: (member ``Bigint``: int64 voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Binary``: byte [] voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Bit``: bool voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Char``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Date``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Datetime``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Datetime2``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Decimal``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Float``: float voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Image``: byte [] voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Int``: int voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Money``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Nchar``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Ntext``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Numeric``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Nvarchar``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Real``: float32 voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Smalldatetime``: DateTime voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Smallint``: int16 voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Smallmoney``: decimal voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Text``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Time``: TimeSpan voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Tinyint``: byte voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Uniqueidentifier``: Guid voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Varbinary``: byte [] voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Varchar``: string voption) dto) |> box
          ValueOption.toDbNull (^a: (member ``Xml``: string voption) dto) |> box
        |]
        |> fun fields -> ``AllTypesNull``(internalUseOnlyValue, fields)


  type ``TempTableAllTypesNullVoption`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableAllTypesNullVoption``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableAllTypesNullVoption``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``AllTypesNull``: seq<``TempTableAllTypesNullVoption``.``AllTypesNull``>
      ) =
      [
        TempTableData
          (
            "#AllTypesNull",
            """
            CREATE TABLE #AllTypesNull (
              [Bigint] BIGINT NULL,
              [Binary] BINARY(42) NULL,
              [Bit] BIT NULL,
              [Char] CHAR(42) NULL,
              [Date] DATE NULL,
              [Datetime] DATETIME NULL,
              [Datetime2] DATETIME2(3) NULL,
              [Datetimeoffset] DATETIMEOFFSET(1) NULL,
              [Decimal] DECIMAL(10, 5) NULL,
              [Float] FLOAT(42) NULL,
              [Image] IMAGE NULL,
              [Int] INT NULL,
              [Money] MONEY NULL,
              [Nchar] NCHAR(42) NULL,
              [Ntext] NTEXT NULL,
              [Numeric] NUMERIC(8, 3) NULL,
              [Nvarchar] NVARCHAR(42) NULL,
              [Real] REAL NULL,
              [Smalldatetime] SMALLDATETIME NULL,
              [Smallint] SMALLINT NULL,
              [Smallmoney] SMALLMONEY NULL,
              [Text] TEXT NULL,
              [Time] TIME(1) NULL,
              [Tinyint] TINYINT NULL,
              [Uniqueidentifier] UNIQUEIDENTIFIER NULL,
              [Varbinary] VARBINARY(42) NULL,
              [Varchar] VARCHAR(42) NULL,
              [Xml] XML NULL
            )

            """,
            (``AllTypesNull`` |> Seq.map (fun x -> x.Fields)),
            28,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``allTypesNull``: seq<``TempTableAllTypesNullVoption``.``AllTypesNull``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``allTypesNull``
        )
      ``TempTableAllTypesNullVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``AllTypesNull``: #seq<``TempTableAllTypesNullVoption``.``AllTypesNull``>) dto)
        )
      ``TempTableAllTypesNullVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableInlined_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM #tempTableInlined

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) =
      {|
        ``Col1`` = reader.GetInt32 ``ordinal_Col1``
        ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableInlined`` =


    type ``tempTableInlined`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTableInlined`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableInlined`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)


  type ``TempTableInlined`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableInlined``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableInlined``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableInlined``: seq<``TempTableInlined``.``tempTableInlined``>
      ) =
      [
        TempTableData
          (
            "#tempTableInlined",
            """
            CREATE TABLE #tempTableInlined (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTableInlined`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableInlined``: seq<``TempTableInlined``.``tempTableInlined``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableInlined``
        )
      ``TempTableInlined_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableInlined``: #seq<``TempTableInlined``.``tempTableInlined``>) dto)
        )
      ``TempTableInlined_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableInlinedDynamic_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        DECLARE @sql NVARCHAR(MAX) =
          'SELECT * FROM #tempTableInlined'

        EXEC sp_executesql @sql, N''

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) =
      {|
        ``Col1`` = reader.GetInt32 ``ordinal_Col1``
        ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableInlinedDynamic`` =


    type ``tempTableInlined`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTableInlined`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableInlined`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)


  type ``TempTableInlinedDynamic`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableInlinedDynamic``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableInlinedDynamic``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableInlined``: seq<``TempTableInlinedDynamic``.``tempTableInlined``>
      ) =
      [
        TempTableData
          (
            "#tempTableInlined",
            """
            CREATE TABLE #tempTableInlined (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTableInlined`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableInlined``: seq<``TempTableInlinedDynamic``.``tempTableInlined``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableInlined``
        )
      ``TempTableInlinedDynamic_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableInlined``: #seq<``TempTableInlinedDynamic``.``tempTableInlined``>) dto)
        )
      ``TempTableInlinedDynamic_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableInlinedWithOtherParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        DECLARE @_someParam INT = @someParam

        SELECT * FROM #tempTableInlined

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Col1`` = 0
    let mutable ``ordinal_Col2`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
      ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

    let getItem (reader: SqlDataReader) =
      {|
        ``Col1`` = reader.GetInt32 ``ordinal_Col1``
        ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetString ``ordinal_Col2`` |> Some
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableInlinedWithOtherParams`` =


    type ``tempTableInlined`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``Col1``: int,
          ``Col2``: string option
        ) : ``tempTableInlined`` =
        [|
          ``Col1`` |> box
          Option.toDbNull ``Col2`` |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableInlined`` =
        [|
          (^a: (member ``Col1``: int) dto) |> box
          Option.toDbNull (^a: (member ``Col2``: string option) dto) |> box
        |]
        |> fun fields -> ``tempTableInlined``(internalUseOnlyValue, fields)


  type ``TempTableInlinedWithOtherParams`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableInlinedWithOtherParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableInlinedWithOtherParams``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableInlined``: seq<``TempTableInlinedWithOtherParams``.``tempTableInlined``>
      ) =
      [
        TempTableData
          (
            "#tempTableInlined",
            """
            CREATE TABLE #tempTableInlined (Col1 INT NOT NULL, Col2 NVARCHAR(42) NULL)
            """,
            (``tempTableInlined`` |> Seq.map (fun x -> x.Fields)),
            2,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableInlined``: seq<``TempTableInlinedWithOtherParams``.``tempTableInlined``>,
        ``someParam``: int
      ) =
      let sqlParams =
        [|
          SqlParameter("@someParam", SqlDbType.Int, Value = ``someParam``)
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableInlined``
        )
      ``TempTableInlinedWithOtherParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@someParam", SqlDbType.Int, Value = (^a: (member ``SomeParam``: int) dto))
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableInlined``: #seq<``TempTableInlinedWithOtherParams``.``tempTableInlined``>) dto)
        )
      ``TempTableInlinedWithOtherParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``TempTableWithLengthTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM #tempTableWithLengthTypes

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_binary`` = 0
    let mutable ``ordinal_char`` = 0
    let mutable ``ordinal_nchar`` = 0
    let mutable ``ordinal_nvarchar`` = 0
    let mutable ``ordinal_varbinary`` = 0
    let mutable ``ordinal_varchar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_binary`` <- reader.GetOrdinal "binary"
      ``ordinal_char`` <- reader.GetOrdinal "char"
      ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
      ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
      ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
      ``ordinal_varchar`` <- reader.GetOrdinal "varchar"

    let getItem (reader: SqlDataReader) =
      {|
        ``binary`` = reader.GetBytes ``ordinal_binary``
        ``char`` = reader.GetString ``ordinal_char``
        ``nchar`` = reader.GetString ``ordinal_nchar``
        ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
        ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
        ``varchar`` = reader.GetString ``ordinal_varchar``
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  module ``TempTableWithLengthTypes`` =


    type ``tempTableWithLengthTypes`` (__: InternalUseOnly, fields: obj []) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member _.Fields = fields

      static member create
        (
          ``binary``: byte [],
          ``char``: string,
          ``nchar``: string,
          ``nvarchar``: string,
          ``varbinary``: byte [],
          ``varchar``: string
        ) : ``tempTableWithLengthTypes`` =
        [|
          ``binary`` |> box
          ``char`` |> box
          ``nchar`` |> box
          ``nvarchar`` |> box
          ``varbinary`` |> box
          ``varchar`` |> box
        |]
        |> fun fields -> ``tempTableWithLengthTypes``(internalUseOnlyValue, fields)

      static member inline create (dto: ^a) : ``tempTableWithLengthTypes`` =
        [|
          (^a: (member ``binary``: byte []) dto) |> box
          (^a: (member ``char``: string) dto) |> box
          (^a: (member ``nchar``: string) dto) |> box
          (^a: (member ``nvarchar``: string) dto) |> box
          (^a: (member ``varbinary``: byte []) dto) |> box
          (^a: (member ``varchar``: string) dto) |> box
        |]
        |> fun fields -> ``tempTableWithLengthTypes``(internalUseOnlyValue, fields)


  type ``TempTableWithLengthTypes`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureBulkCopy : SqlBulkCopy -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    member this.ConfigureBulkCopy(configureBulkCopy: SqlBulkCopy -> unit) =
      this.userConfigureBulkCopy <- configureBulkCopy
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``TempTableWithLengthTypes``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``TempTableWithLengthTypes``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member this.CreateTempTableData
      (
        ``tempTableWithLengthTypes``: seq<``TempTableWithLengthTypes``.``tempTableWithLengthTypes``>
      ) =
      [
        TempTableData
          (
            "#tempTableWithLengthTypes",
            """
            CREATE TABLE #tempTableWithLengthTypes (
              [binary] BINARY(3) NOT NULL,
              [char] CHAR(3) NOT NULL,
              [nchar] NCHAR(3) NOT NULL,
              [nvarchar] NVARCHAR(3) NOT NULL,
              [varbinary] VARBINARY(3) NOT NULL,
              [varchar] VARCHAR(3) NOT NULL
            )

            """,
            (``tempTableWithLengthTypes`` |> Seq.map (fun x -> x.Fields)),
            6,
            Action<_> this.userConfigureBulkCopy
          )
      ]
    member this.WithParameters
      (
        ``tempTableWithLengthTypes``: seq<``TempTableWithLengthTypes``.``tempTableWithLengthTypes``>
      ) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          ``tempTableWithLengthTypes``
        )
      ``TempTableWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
        |]
      let tempTableData =
        this.CreateTempTableData(
          (^a: (member ``TempTableWithLengthTypes``: #seq<``TempTableWithLengthTypes``.``tempTableWithLengthTypes``>) dto)
        )
      ``TempTableWithLengthTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTableData)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``UserDefinedTableType_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

    let configureCmd (cmd: SqlCommand) =
      cmd.CommandText <- """
        SELECT * FROM @tvp

      """
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Foo`` = 0
    let mutable ``ordinal_Bar`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
      ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

    let getItem (reader: SqlDataReader) =
      {|
        ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
        ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
      |}

    member _.ExecuteAsync(?cancellationToken) =
      executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

    member _.LazyExecuteAsync(?cancellationToken) =
      executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    #endif

    member _.LazyExecute() =
      executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


  type ``UserDefinedTableType`` private (connStr: string, conn: SqlConnection) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``UserDefinedTableType``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection) = ``UserDefinedTableType``(null, connection)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
      ) =
      let sqlParams =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``tvp``)
        |]
      ``UserDefinedTableType_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

    member inline this.WithParameters(dto: ^a) =
      let sqlParams =
        [|
          SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
        |]
      ``UserDefinedTableType_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  module ``Option`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``In_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT @param1

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


      type ``In`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``In``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``In``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string option
          ) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``Out_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT @param1

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


      type ``Out`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``Out``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``Out``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string option
          ) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


      type ``TableOutWithDto`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM OptionTableWithDto

          """
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.OptionTableWithDto =
          {
            ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
            ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TableOutWithDto``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


      type ``TableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM OptionTableWithoutDto

          """
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) =
          {|
            ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
            ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          |}

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TableOutWithoutDto``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``TvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM @tvp

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Foo`` = 0
        let mutable ``ordinal_Bar`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
          ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

        let getItem (reader: SqlDataReader) =
          {|
            ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
            ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
          |}

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


      type ``TvpInOut`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TvpInOut``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
          ) =
          let sqlParams =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``tvp``)
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


  module ``SubPath`` =


      type ``SelectAllFromTable`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM Table1

          """
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
          {
            ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
            ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``SelectAllFromTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``SelectAllFromTable``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


  module ``Voption`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``In_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT @param1

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem tempTableData


      type ``In`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``In``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``In``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string voption
          ) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull ``param1``)
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull (^a: (member ``Param1``: string voption) dto))
            |]
          ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``Out_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT @param1

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then ValueNone else reader.GetString 0 |> ValueSome

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData


      type ``Out`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``Out``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``Out``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``param1``: string option
          ) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
            |]
          ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])


      type ``TableOutWithDto`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM VoptionTableWithDto

          """
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.VoptionTableWithDto =
          {
            ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
            ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TableOutWithDto``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


      type ``TableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM VoptionTableWithoutDto

          """
          userConfigureCmd cmd

        let mutable ``ordinal_Col1`` = 0
        let mutable ``ordinal_Col2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
          ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

        let getItem (reader: SqlDataReader) =
          {|
            ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
            ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
          |}

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TableOutWithoutDto``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``TvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTableData: seq<TempTableData>) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM @tvp

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Foo`` = 0
        let mutable ``ordinal_Bar`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
          ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

        let getItem (reader: SqlDataReader) =
          {|
            ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then ValueNone else reader.GetInt32 ``ordinal_Foo`` |> ValueSome
            ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then ValueNone else reader.GetString ``ordinal_Bar`` |> ValueSome
          |}

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem tempTableData

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem tempTableData


      type ``TvpInOut`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TvpInOut``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``tvp``: seq<TableTypes.``dbo``.``MultiColNullVoption``>
          ) =
          let sqlParams =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = ``tvp``)
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNullVoption``>) dto))
            |]
          ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, [])
